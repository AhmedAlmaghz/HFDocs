# الضبط الكمي 

الضبط الكمي هو تقنية لخفض التكاليف الحسابية وتكاليف الذاكرة لتشغيل الاستدلال عن طريق تمثيل الأوزان والتنشيطات بأنواع بيانات منخفضة الدقة مثل 8 بت صحيح (`int8`) بدلاً من 32 بت عائم (`float32`) المعتادة.

إن تقليل عدد البتات يعني أن النموذج الناتج يتطلب مساحة تخزين أقل في الذاكرة، ويستهلك طاقة أقل (نظريًا)، ويمكن إجراء عمليات مثل الضرب في المصفوفة بشكل أسرع بكثير باستخدام الحساب الصحيح. كما يسمح بتشغيل النماذج على الأجهزة المدمجة، والتي تدعم في بعض الأحيان أنواع بيانات صحيحة فقط.

## النظرية

الفكرة الأساسية وراء الضبط الكمي بسيطة للغاية: الانتقال من تمثيل عالي الدقة (عادة 32 بت عائم عادي) للأوزان والتنشيطات إلى نوع بيانات أقل دقة. وأنواع البيانات الأقل دقة الشائعة هي:

- `float16`، نوع بيانات التراكم `float16`
- `bfloat16`، نوع بيانات التراكم `float32`
- `int16`، نوع بيانات التراكم `int32`
- `int8`، نوع بيانات التراكم `int32`

يحدد نوع بيانات التراكم نوع نتيجة تراكم (إضافة أو ضرب، وما إلى ذلك) القيم من نوع البيانات المعني. على سبيل المثال، لنأخذ قيمتين `int8` `A = 127`، `B = 127`، ولنحدد `C` على أنه مجموع `A` و`B`:

```
C = A + B
```

هنا، النتيجة أكبر بكثير من أكبر قيمة يمكن تمثيلها في `int8`، والتي هي `127`. ومن هنا تأتي الحاجة إلى نوع بيانات أكبر دقة لتجنب فقدان الدقة الهائل الذي من شأنه أن يجعل عملية الضبط الكمي بأكملها عديمة الفائدة.

## الضبط الكمي

حالتا الضبط الكمي الأكثر شيوعًا هما `float32 -> float16` و`float32 -> int8`.

### الضبط الكمي إلى `float16`

إن إجراء الضبط الكمي للانتقال من `float32` إلى `float16` أمر مباشر إلى حد ما لأن كلا نوعي البيانات يتبعان نفس نظام التمثيل. والأسئلة التي يجب أن تطرحها على نفسك عند ضبط عملية إلى `float16` هي:

- هل يوجد تنفيذ `float16` لعملية؟
- هل يدعم عتادي `float16`؟ على سبيل المثال، كانت معالجات Intel تدعم `float16` كنوع تخزين، ولكن يتم إجراء الحساب بعد التحويل إلى `float32`. سيأتي الدعم الكامل في Cooper Lake وSapphire Rapids.
- هل عملية حساسة للدقة المنخفضة؟

على سبيل المثال، تكون قيمة epsilon في `LayerNorm` عادة صغيرة جدًا (~ `1e-12`)، ولكن أصغر قيمة يمكن تمثيلها في `float16` هي ~ `6e-5`، ويمكن أن يتسبب ذلك في مشكلات `NaN`. وينطبق الشيء نفسه على القيم الكبيرة.

### الضبط الكمي إلى `int8`

إن إجراء الضبط الكمي للانتقال من `float32` إلى `int8` أكثر تعقيدًا. يمكن تمثيل 256 قيمة فقط في `int8`، في حين أن `float32` يمكن أن يمثل نطاقًا واسعًا جدًا من القيم. والفكرة هي إيجاد أفضل طريقة لمشروع نطاقنا `[a، b]` من قيم `float32` إلى مساحة `int8`.

لنأخذ في الاعتبار عددًا عائمًا `x` في `[a، b]`، إذن يمكننا كتابة مخطط الضبط الكمي التالي، والذي يُطلق عليه أيضًا مخطط الضبط الكمي *الخطي*:

```
x = S * (x_q - Z)
```

حيث:

- `x_q` هي القيمة المضبوطة `int8` المقترنة بـ `x`
- `S` و`Z` هما معاملا الضبط الكمي
- `S` هو المقياس، وهو عدد موجب `float32`
- `Z` يُسمى نقطة الصفر، وهي قيمة `int8` المقابلة للقيمة `0` في مجال `float32`. هذا أمر مهم لتمثيل القيمة `0` بدقة لأنها تستخدم في كل مكان في نماذج التعلم الآلي.

يمكن حساب القيمة المضبوطة `x_q` لـ `x` في `[a، b]` على النحو التالي:

```
x_q = round(x/S + Z)
```

وتتم تقليم قيم `float32` خارج النطاق `[a، b]` إلى أقرب قيمة يمكن تمثيلها، لذا لأي رقم عشري `x`:

```
x_q = clip(round(x/S + Z), round(a/S + Z), round(b/S + Z))
```

<Tip>
عادةً ما يقابل `round(a/S + Z)` أصغر قيمة يمكن تمثيلها في نوع البيانات قيد النظر، و`round(b/S + Z)` لأكبر قيمة. ولكن يمكن أن يختلف هذا، على سبيل المثال عند استخدام مخطط الضبط الكمي *المتماثل* كما سترى في الفقرة التالية.
</Tip>

### مخططات الضبط الكمي المتماثلة والخطية

تسمى المعادلة أعلاه بمخطط الضبط الكمي *الخطي* لأن الخريطة من `[a، b]` إلى `int8` هي خريطة خطية.

حالة خاصة شائعة من هذا المخطط هي مخطط الضبط الكمي *المتماثل*، حيث نأخذ في الاعتبار نطاقًا متماثلًا للقيم العائمة `[-a، a]`.

في هذه الحالة، يكون نطاق الأعداد الصحيحة عادةً `[-127، 127]`، مما يعني أنه يتم استبعاد `-128` من نطاق `int8` الموقّع العادي `[−128، 127]`. والسبب في ذلك هو أن وجود كلا النطاقين متماثلين يسمح بأن يكون `Z = 0`. في حين يتم فقدان إحدى القيم من بين 256 قيمة يمكن تمثيلها، يمكن أن يوفر ذلك تسريعًا لأن العديد من عمليات الجمع يمكن تخطيها.

**ملاحظة**: لمعرفة كيفية حساب معاملات الضبط الكمي `S` و`Z`، يمكنك قراءة ورقة "ضبط وتدريب الشبكات العصبية للتحقيق الفعال لاستنتاج الحساب الصحيح فقط" [Quantization and Training of Neural Networks for Efficient Integer-Arithmetic-Only Inference](https://arxiv.org/abs/1712.05877) أو تدوينة Lei Mao [Lei Mao's blog post](https://leimao.github.io/article/Neural-Networks-Quantization) حول هذا الموضوع.

### الضبط الكمي لكل موتر وكل قناة

اعتمادًا على التوازن بين الدقة والتأخير الذي تستهدفه، يمكنك اللعب بدقة معاملات الضبط الكمي:

- يمكن حساب معاملات الضبط الكمي على أساس *كل موتر*، مما يعني أنه سيتم استخدام زوج واحد من `(S، Z)` لكل موتر.
- يمكن حساب معاملات الضبط الكمي على أساس *كل قناة*، مما يعني أنه من الممكن تخزين زوج واحد من `(S، Z)` لكل عنصر على طول أحد أبعاد الموتر. على سبيل المثال، بالنسبة لموتر الشكل `[N، C، H، W]`، فإن وجود معاملات ضبط كلي لكل قناة للبعد الثاني سينتج عنه وجود `C` أزواج من `(S، Z)`. في حين أن هذا يمكن أن يعطي دقة أفضل، فإنه يتطلب ذاكرة أكبر.

### المعايرة

وصف القسم أعلاه كيفية عمل الضبط الكمي من `float32` إلى `int8`، ولكن يبقى سؤال واحد: كيف يتم تحديد نطاق `[a، b]` من قيم `float32`؟ هذا هو المكان الذي تأتي فيه المعايرة.

المعايرة هي الخطوة أثناء الضبط الكمي التي يتم فيها حساب نطاقات `float32`. بالنسبة للأوزان، فهي سهلة إلى حد ما لأن النطاق الفعلي معروف في *وقت الضبط الكمي*. ولكن الأمر أقل وضوحًا بالنسبة للتنشيطات، وهناك نهج مختلفة:

1. الضبط الكمي الديناميكي بعد التدريب: يتم حساب النطاق لكل تنشيط أثناء التنقل في *وقت التشغيل*. في حين أن هذا يعطي نتائج رائعة دون الكثير من العمل، فقد يكون أبطأ قليلاً من الضبط الكمي الثابت بسبب العبء الزائد الذي تفرضه عملية حساب النطاق في كل مرة. كما أنه ليس خيارًا على أجهزة معينة.
2. الضبط الكمي الثابت بعد التدريب: يتم حساب النطاق لكل تنشيط مسبقًا في *وقت الضبط الكمي*، عادةً عن طريق تمرير البيانات التمثيلية عبر النموذج وتسجيل قيم التنشيط. في الممارسة العملية، الخطوات هي:
    1. يتم وضع المراقبين على التنشيطات لتسجيل قيمها.
    2. يتم إجراء عدد معين من عمليات التغذية الأمامية على مجموعة بيانات المعايرة (حوالي 200 مثال كافٍ).
    3. يتم حساب النطاقات لكل عملية حسابية وفقًا لبعض *تقنيات المعايرة*.
3. الضبط الكمي أثناء التدريب: يتم حساب النطاق لكل تنشيط في *وقت التدريب*، باتباع نفس فكرة الضبط الكمي الثابت بعد التدريب. ولكن يتم استخدام مشغلات "الضبط الكمي المزيف" بدلاً من المراقبين: فهي تسجل القيم مثل المراقبين، ولكنها تحاكي أيضًا الخطأ الذي يسببه الضبط الكمي للسماح للنموذج بالتكيف معه.

بالنسبة لكل من الضبط الكمي الثابت بعد التدريب والضبط الكمي أثناء التدريب، من الضروري تحديد تقنيات المعايرة، والأكثر شيوعًا هي:

- الحد الأدنى والحد الأقصى: النطاق المحسوب هو `[أصغر قيمة ملحوظة، أكبر قيمة ملحوظة]`، وهذا يعمل بشكل جيد مع الأوزان.
- المتوسط المتحرك للحد الأدنى والحد الأقصى: النطاق المحسوب هو `[متوسط متحرك للحد الأدنى للقيمة الملحوظة، متوسط متحرك للحد الأقصى للقيمة الملحوظة]`، وهذا يعمل بشكل جيد مع التنشيطات.
- مخطط بياني: يسجل مخططًا بيانيًا للقيم إلى جانب الحد الأدنى والحد الأقصى للقيم، ثم يختار وفقًا لمعيار ما:
    - إنتروبيا: يتم حساب النطاق على أنه النطاق الذي يقلل الخطأ بين البيانات ذات الدقة الكاملة والبيانات المضبوطة.
    - متوسط ​​الخطأ التربيعي: يتم حساب النطاق على أنه النطاق الذي يقلل متوسط ​​الخطأ التربيعي بين البيانات ذات الدقة الكاملة والبيانات المضبوطة.
    - المئيني: يتم حساب النطاق باستخدام قيمة مئينية معينة `p` على القيم الملحوظة. الفكرة هي محاولة الحصول على `p%` من القيم الملحوظة في النطاق المحسوب. في حين أن هذا ممكن عند إجراء الضبط الكمي الخطي، إلا أنه ليس من الممكن دائمًا مطابقته تمامًا عند إجراء الضبط الكمي المتماثل. يمكنك التحقق من [كيفية القيام بذلك في ONNX Runtime](https://github.com/microsoft/onnxruntime/blob/2cb12caf9317f1ded37f6db125cb03ba99320c40/onnxruntime/python/tools/quantization/calibrate.py#L698) لمزيد من التفاصيل.

### الخطوات العملية لضبط نموذج إلى `int8`

لضبط نموذج بشكل فعال إلى `int8`، فإن الخطوات التي يجب اتباعها هي:

1. اختر المشغلين الذين سيتم ضبطهم. المشغلون الجيدون للضبط هم المشغلون الذين يهيمنون على وقت الحساب، على سبيل المثال، الإسقاطات الخطية وضرب المصفوفة.
2. جرب الضبط الكمي الديناميكي بعد التدريب، إذا كان سريعًا بما يكفي، فتوقف هنا، وإلا فانتقل إلى الخطوة 3.
3. جرب الضبط الكمي الثابت بعد التدريب والذي يمكن أن يكون أسرع من الضبط الكمي الديناميكي ولكنه غالبًا ما يكون مصحوبًا بانخفاض في الدقة. قم بتطبيق المراقبين على نماذجك في الأماكن التي تريد ضبطها.
4. اختر تقنية معايرة وقم بتنفيذها.
5. قم بتحويل النموذج إلى شكله المضبوط: تتم إزالة المراقبين وتحويل مشغلات `float32` إلى نظرائهم `int8`.
6. قيم النموذج المضبوط: هل الدقة جيدة بما يكفي؟ إذا كان الأمر كذلك، فتوقف هنا، وإلا فابدأ مرة أخرى من الخطوة 3 ولكن باستخدام الضبط الكمي أثناء التدريب هذه المرة.

## الأدوات المدعومة لإجراء الضبط الكمي في 🤗 Optimum

يوفر 🤗 Optimum واجهات برمجة التطبيقات (APIs) لإجراء الضبط الكمي باستخدام أدوات مختلفة لأهداف مختلفة:

- تسمح حزمة `optimum.onnxruntime` بـ [ضبط نماذج ONNX وتشغيلها](https://huggingface.co/docs/optimum/onnxruntime/usage_guides/quantization) باستخدام أداة ONNX Runtime.
- تمكّن حزمة `optimum.intel` من [ضبط](https://huggingface.co/docs/optimum/intel/optimization_inc) نماذج 🤗 Transformers مع احترام قيود الدقة والتأخير.
- توفر حزمة `optimum.fx` أغلفة حول [وظائف الضبط الكمي PyTorch](https://pytorch.org/docs/stable/quantization-support.html#torch-quantization-quantize-fx) للسماح بالضبط الكمي لوضع الرسم البياني لنماذج 🤗 Transformers في PyTorch. هذه واجهة برمجة تطبيقات منخفضة المستوى مقارنة بالاثنتين المذكورتين أعلاه، مما يمنحك مرونة أكبر، ولكنه يتطلب المزيد من العمل من جانبك.
- تسمح حزمة `optimum.gptq` بـ [ضبط نماذج LLM وتشغيلها](../llm_quantization/usage_guides/quantization) باستخدام GPTQ.
## الاستفاضة: كيف تمثل الآلات الأعداد؟

<Tip>
هذا القسم غير أساسي لفهم بقية الموضوع. فهو يشرح بإيجاز كيفية تمثيل الأعداد في الحواسيب.
وبما أن التكميم يتعلق بالانتقال من تمثيل إلى آخر، فقد يكون من المفيد معرفة بعض الأساسيات، ولكنه بالتأكيد ليس إلزاميًا.
</Tip>

أصغر وحدة تمثيل في الحواسيب هي البت. كل شيء في الحواسيب يُمثل على شكل سلسلة من البتات، بما في ذلك الأعداد. ولكن طريقة التمثيل تختلف حسب ما إذا كانت الأعداد قيد النقاش أعدادًا صحيحة أو أعدادًا حقيقية.

#### تمثيل الأعداد الصحيحة

عادة ما تُمثل الأعداد الصحيحة بأطوال البتات التالية: `8`، `16`، `32`، `64`. عند تمثيل الأعداد الصحيحة، هناك حالتان يجب مراعاتهما:

1. الأعداد الصحيحة غير الموقعة (الإيجابية): تُمثل ببساطة على شكل سلسلة من البتات. كل بت يتوافق مع قوة عدد اثنين (من `0` إلى `n-1` حيث `n` هو طول البت)، والعدد الناتج هو مجموع قوى العدد اثنين هذه.

المثال: `19` يُمثل على شكل عدد صحيح غير مُوقع بطول 8 بتات `00010011` لأن:

```
19 = 0 x 2^7 + 0 x 2^6 + 0 x 2^5 + 1 x 2^4 + 0 x 2^3 + 0 x 2^2 + 1 x 2^1 + 1 x 2^0
```

2. الأعداد الصحيحة الموقعة: إن تمثيل الأعداد الصحيحة الموقعة ليس مباشرًا، وهناك عدة طرق للقيام بذلك، أكثرها شيوعًا هي طريقة المتممة للاثنين. لمزيد من المعلومات، يمكنك الاطلاع على صفحة
[ويكيبيديا](https://en.wikipedia.org/wiki/Signed_number_representations) حول هذا الموضوع.

#### تمثيل الأعداد الحقيقية

عادة ما تُمثل الأعداد الحقيقية بأطوال البتات التالية: `16`، `32`، `64`.

هناك طريقتان رئيسيتان لتمثيل الأعداد الحقيقية:

1. النقطة الثابتة: هناك عدد ثابت من الخانات محجوز لتمثيل الجزء الصحيح والجزء الكسري من العدد.

2. النقطة العائمة: يمكن أن يختلف عدد الخانات المستخدمة لتمثيل الجزء الصحيح والجزء الكسري من العدد.

يمكن لتمثيل النقطة العائمة أن يمثل نطاقات أكبر من القيم، وهذا هو ما سنركز عليه لأنه الأكثر استخدامًا. هناك ثلاثة مكونات في تمثيل النقطة العائمة:

1. بت الإشارة: هذا هو البت الذي يحدد إشارة العدد.

2. الجزء الأسّي:
- 5 بتات في `float16`
- 8 بتات في `bfloat16`
- 8 بتات في `float32`
- 11 بتًا في `float64`

3. المنوال:
- 11 بتًا في `float16` (10 مخزنة بشكل صريح)
- 8 بتات في `bfloat16` (7 مخزنة بشكل صريح)
- 24 بتًا في `float32` (23 مخزنة بشكل صريح)
- 53 بتًا في `float64` (52 مخزنة بشكل صريح)

لمزيد من المعلومات حول تخصيص البتات لكل نوع من البيانات، راجع الرسم التوضيحي على صفحة ويكيبيديا حول تنسيق النقطة العائمة [bfloat16](https://en.wikipedia.org/wiki/Bfloat16_floating-point_format).

بالنسبة للعدد الحقيقي "س"، لدينا:

```
x = sign x mantissa x (2^exponent)
```

## المراجع

- ورقة بحثية: [Quantization and Training of Neural Networks for Efficient Integer-Arithmetic-Only Inference](https://arxiv.org/abs/1712.05877)

- منشور مدونة للمبتدئين: [Basics of Quantization in Machine Learning (ML) for Beginners](https://iq.opengenus.org/basics-of-quantization-in-ml/)

- منشور مدونة: [How to accelerate and compress neural networks with quantization](https://tivadardanka.com/blog/neural-networks-quantization)

- صفحات ويكيبيديا حول تمثيل الأعداد الصحيحة [هنا](https://en.wikipedia.org/wiki/Integer_(computer_science)) و[هنا](https://en.wikipedia.org/wiki/Signed_number_representations)

- صفحات ويكيبيديا حول:

- [تنسيق النقطة العائمة bfloat16](https://en.wikipedia.org/wiki/Bfloat16_floating-point_format)

- [تنسيق النقطة العائمة بنصف الدقة](https://en.wikipedia.org/wiki/Half-precision_floating-point_format)

- [تنسيق النقطة العائمة ذات الدقة المنفردة](https://en.wikipedia.org/wiki/Single-precision_floating-point_format)

- [تنسيق النقطة العائمة ذات الدقة المضاعفة](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)