# ุงูุชุญุณูู

ูููุฑ ูุญุฏุฉ `optimum.fx.optimization` ูุฌููุนุฉ ูู ุชุญูููุงุช ูุฎุทุท torch.fxุ ุฌูุจูุง ุฅูู ุฌูุจ ูุน ุงููุฆุงุช ูุงููุธุงุฆู ููุชุงุจุฉ ุชุญูููุงุชู ุงูุฎุงุตุฉ ูุชูููููุง.

## ุฏููู ุงูุชุญููู

ูู ๐ค Optimumุ ููุงู ููุนุงู ูู ุงูุชุญูููุงุช: ุงูุชุญูููุงุช ุงููุงุจูุฉ ููุชุฑุงุฌุน ูุบูุฑ ุงููุงุจูุฉ ููุชุฑุงุฌุน.

### ูุชุงุจุฉ ุชุญููู ุบูุฑ ูุงุจู ููุชุฑุงุฌุน

ุฃุจุณุท ุญุงูุงุช ุงูุชุญูููุงุช ูู ุงูุชุญูููุงุช ุบูุฑ ุงููุงุจูุฉ ููุชุฑุงุฌุน. ูุง ูููู ุนูุณ ูุฐู ุงูุชุญูููุงุชุ ููุง ูุนูู ุฃูู ุจุนุฏ ุชุทุจูููุง ุนูู ูุญุฏุฉ ููุทูุฉ ููุฑุณูุ ูุง ุชูุฌุฏ ุทุฑููุฉ ูุงุณุชุนุงุฏุฉ ุงููููุฐุฌ ุงูุฃุตูู. ูุชูููุฐ ูุซู ูุฐู ุงูุชุญูููุงุช ูู ๐ค Optimumุ ุงูุฃูุฑ ุณูู ููุบุงูุฉ: ูุง ุนููู ุณูู ุฅูุดุงุก ูุฆุฉ ูุฑุนูุฉ ูู [`~optimum.fx.optimization.Transformation`] ูุชูููุฐ ุทุฑููุฉ [`~optimum.fx.optimization.Transformation.transform`].

ุนูู ุณุจูู ุงููุซุงูุ ูููู ุงูุชุญููู ุงูุชุงูู ุจุชุบููุฑ ุฌููุน ุนูููุงุช ุงูุถุฑุจ ุฅูู ุนูููุงุช ุฌูุน:

```python
>>> import operator
>>> from optimum.fx.optimization import Transformation

>>> class ChangeMulToAdd(Transformation):
...     def transform(self, graph_module):
...         for node in graph_module.graph.nodes:
...             if node.op == "call_function" and node.target == operator.mul:
...                 node.target = operator.add
...         return graph_module
```

ุจุนุฏ ุชูููุฐูุ ูููู ุงุณุชุฎุฏุงู ุชุญูููู ูุฏุงูุฉ ุนุงุฏูุฉ:

```python
>>> from transformers import BertModel
>>> from transformers.utils.fx import symbolic_trace

>>> model = BertModel.from_pretrained("bert-base-uncased")
>>> traced = symbolic_trace(
...     model,
...     input_names=["input_ids", "attention_mask", "token_type_ids"],
... )

>>> transformation = ChangeMulToAdd()
>>> transformed_model = transformation(traced)
```

### ูุชุงุจุฉ ุชุญููู ูุงุจู ููุชุฑุงุฌุน

ูููุฐ ุงูุชุญููู ุงููุงุจู ููุชุฑุงุฌุน ูู ูู ุงูุชุญููู ูุนูุณูุ ููุง ูุณูุญ ุจุงุณุชุฑุฏุงุฏ ุงููููุฐุฌ ุงูุฃุตูู ูู ุงููุญูู. ูุชูููุฐ ูุซู ูุฐุง ุงูุชุญูููุ ุชุญุชุงุฌ ุฅูู ุฅูุดุงุก ูุฆุฉ ูุฑุนูุฉ ูู [`~optimum.fx.optimization.ReversibleTransformation`] ูุชูููุฐ ุทุฑู [`~optimum.fx.optimization.ReversibleTransformation.transform`] ู [`~optimum.fx.optimization.ReversibleTransformation.reverse`].

ุนูู ุณุจูู ุงููุซุงูุ ุงูุชุญููู ุงูุชุงูู ูุงุจู ููุชุฑุงุฌุน:

```python
>>> import operator
>>> from optimum.fx.optimization import ReversibleTransformation

>>> class MulToMulTimesTwo(ReversibleTransformation):
...     def transform(self, graph_module):
...         for node in graph_module.graph.nodes:
...             if node.op == "call_function" and node.target == operator.mul:
...                 x, y = node.args
...                 node.args = (2 * x, y)
...         return graph_module
...
...     def reverse(self, graph_module):
...         for node in graph_module.graph.nodes:
...             if node.op == "call_function" and node.target == operator.mul:
...                 x, y = node.args
...                 node.args = (x / 2, y)
...         return graph_module
```

### ุชูููู ุงูุชุญูููุงุช ูุนูุง

ูุธุฑูุง ูุฃู ุชุทุจูู ุชุญูููุงุช ูุชุนุฏุฏุฉ ูู ุงูุณูุณูุฉ ูุทููุจ ูู ูุซูุฑ ูู ุงูุฃุญูุงูุ ูุชู ุชูููุฑ [`~optimum.fx.optimization.compose`]. ุฅููุง ุฏุงูุฉ ูุณุงุนุฏุฉ ุชุณูุญ ูู ุจุฅูุดุงุก ุชุญููู ุนู ุทุฑูู ุชุณูุณู ุชุญูููุงุช ูุชุนุฏุฏุฉ ุฃุฎุฑู.

```python
>>> from optimum.fx.optimization import compose
>>> composition = compose(MulToMulTimesTwo(), ChangeMulToAdd())
```

ูู ูุฐู ุงูุชุฑุฌูุฉ ูุงุถุญุฉ ููููููุฉุ ูุง ุชุชุฑุฏุฏ ูู ุฅุฎุจุงุฑู ุฅุฐุง ููุช ุชุฑูุฏ ููู ุชูุถูุญ ุฃู ุดูุก ุฃู ุชูุฏูู ุงููุฒูุฏ ูู ุงูุชูุงุตูู.